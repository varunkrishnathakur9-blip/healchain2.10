import dotenv from "dotenv";
dotenv.config();

import { ethers } from "ethers";

async function main() {
  console.log("ğŸš€ Deploying StakeRegistry to Network");

  // Setup provider and wallet
  const rpcUrl = process.env.RPC_URL || process.env.SEPOLIA_RPC_URL;
  const privateKey = process.env.DEPLOYER_PRIVATE_KEY || process.env.BACKEND_PRIVATE_KEY;
  
  if (!rpcUrl || !privateKey) {
    console.error("âŒ Missing RPC_URL/SEPOLIA_RPC_URL or DEPLOYER_PRIVATE_KEY/BACKEND_PRIVATE_KEY in environment");
    process.exit(1);
  }

  const provider = new ethers.JsonRpcProvider(rpcUrl);
  const wallet = new ethers.Wallet(privateKey, provider);
  
  console.log("Deployer:", wallet.address);
  const balance = await provider.getBalance(wallet.address);
  console.log("Balance:", ethers.formatEther(balance), "ETH");
  
  if (balance === 0n) {
    console.error("âŒ Deployer has no balance. Please fund the account.");
    process.exit(1);
  }

  // Read contract artifacts
  const fs = await import('fs/promises');
  const path = await import('path');
  
  // Read StakeRegistry ABI
  const artifactPath = path.join(process.cwd(), 'artifacts', 'src', 'StakeRegistry.sol', 'StakeRegistry.json');
  
  let artifact;
  try {
    artifact = JSON.parse(await fs.readFile(artifactPath, 'utf8'));
  } catch (error) {
    console.error("âŒ Could not read StakeRegistry artifact. Make sure contract is compiled:");
    console.error("   forge build");
    process.exit(1);
  }

  // Deploy StakeRegistry
  const StakeRegistryFactory = new ethers.ContractFactory(
    artifact.abi,
    artifact.bytecode,
    wallet
  );
  
  console.log("\nğŸ“¦ Deploying StakeRegistry...");
  const stakeRegistry = await StakeRegistryFactory.deploy(wallet.address); // Owner address
  await stakeRegistry.waitForDeployment();
  const stakeRegistryAddress = await stakeRegistry.getAddress();
  console.log("âœ… StakeRegistry deployed to:", stakeRegistryAddress);

  // Get network info
  const network = await provider.getNetwork();
  console.log("ğŸŒ Network:", network.name, `(Chain ID: ${network.chainId})`);

  // Verify deployment
  const minStake = await stakeRegistry.MIN_STAKE();
  const unlockDelay = await stakeRegistry.UNLOCK_DELAY();
  console.log("\nğŸ“‹ Contract Configuration:");
  console.log("   Minimum Stake:", ethers.formatEther(minStake), "ETH");
  console.log("   Unlock Delay:", Number(unlockDelay) / 86400, "days");

  // Update environment files
  console.log("\nğŸ“ Updating environment files...");
  
  const projectRoot = process.cwd();
  const backendEnvPath = path.join(projectRoot, '..', 'backend', '.env.development');
  const backendEnvProdPath = path.join(projectRoot, '..', 'backend', '.env.production');

  // Helper function to update or add env variable
  const updateEnvVar = (content, varName, value) => {
    const regex = new RegExp(`^[#\\s]*${varName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}=.*$`, 'm');
    if (regex.test(content)) {
      return content.replace(regex, `${varName}=${value}`);
    } else {
      // Add to contract addresses section or create it
      const contractSection = /# Contract Addresses.*?(?=\n#|$)/s;
      if (contractSection.test(content)) {
        return content.replace(contractSection, (match) => match + `\n${varName}=${value}`);
      } else {
        // Add new section
        const rpcSection = /# RPC Configuration.*/;
        if (rpcSection.test(content)) {
          return content.replace(
            rpcSection,
            (match) => match + `\n\n# Contract Addresses\n${varName}=${value}`
          );
        } else {
          return content + `\n${varName}=${value}`;
        }
      }
    }
  };

  // Update backend .env.development
  try {
    let backendEnv = '';
    try {
      backendEnv = await fs.readFile(backendEnvPath, 'utf8');
    } catch {
      // File doesn't exist, create template
      backendEnv = `# HealChain Backend - Development Environment Variables
# Auto-generated by deployment script
# Last updated: ${new Date().toISOString()}

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/healchain

# RPC Configuration
RPC_URL=http://localhost:8545

# Contract Addresses
ESCROW_ADDRESS=
STAKE_REGISTRY_ADDRESS=
`;
    }
    
    backendEnv = updateEnvVar(backendEnv, 'STAKE_REGISTRY_ADDRESS', stakeRegistryAddress);
    
    // Update timestamp
    if (backendEnv.includes('# Last updated:')) {
      backendEnv = backendEnv.replace(
        /# Last updated:.*/,
        `# Last updated: ${new Date().toISOString()}`
      );
    }
    
    await fs.writeFile(backendEnvPath, backendEnv, 'utf8');
    console.log(`   âœ… Updated backend/.env.development`);
  } catch (error) {
    console.log(`   âš ï¸  Could not update backend/.env.development: ${error.message}`);
  }

  // Update backend .env.production
  try {
    let backendEnvProd = '';
    try {
      backendEnvProd = await fs.readFile(backendEnvProdPath, 'utf8');
    } catch {
      console.log(`   âš ï¸  backend/.env.production not found, skipping...`);
    }
    
    if (backendEnvProd) {
      backendEnvProd = updateEnvVar(backendEnvProd, 'STAKE_REGISTRY_ADDRESS', stakeRegistryAddress);
      
      // Update timestamp
      if (backendEnvProd.includes('# Last updated:')) {
        backendEnvProd = backendEnvProd.replace(
          /# Last updated:.*/,
          `# Last updated: ${new Date().toISOString()}`
        );
      }
      
      await fs.writeFile(backendEnvProdPath, backendEnvProd, 'utf8');
      console.log(`   âœ… Updated backend/.env.production`);
    }
  } catch (error) {
    console.log(`   âš ï¸  Could not update backend/.env.production: ${error.message}`);
  }

  // Save deployment info
  const deploymentsPath = path.join(projectRoot, 'deployments', 'stake-registry.json');
  const deploymentInfo = {
    address: stakeRegistryAddress,
    network: network.name,
    chainId: Number(network.chainId),
    deployer: wallet.address,
    deployedAt: new Date().toISOString(),
    minStake: minStake.toString(),
    unlockDelay: unlockDelay.toString(),
  };

  try {
    await fs.mkdir(path.dirname(deploymentsPath), { recursive: true });
    await fs.writeFile(deploymentsPath, JSON.stringify(deploymentInfo, null, 2), 'utf8');
    console.log(`   âœ… Saved deployment info to deployments/stake-registry.json`);
  } catch (error) {
    console.log(`   âš ï¸  Could not save deployment info: ${error.message}`);
  }

  console.log("\n" + "=".repeat(60));
  console.log("âœ… Deployment Summary");
  console.log("=".repeat(60));
  console.log("Contract: StakeRegistry");
  console.log("Address:", stakeRegistryAddress);
  console.log("Network:", network.name, `(Chain ID: ${network.chainId})`);
  console.log("Minimum Stake:", ethers.formatEther(minStake), "ETH");
  console.log("Unlock Delay:", Number(unlockDelay) / 86400, "days");
  console.log("\nğŸ’¡ Next steps:");
  console.log("   1. Add STAKE_REGISTRY_ADDRESS to backend/.env.development or .env.production");
  console.log("   2. Restart backend to pick up the new contract address");
  console.log("   3. Miners can now deposit stakes using:");
  console.log(`      stakeRegistry.depositStake({ value: ethers.parseEther("1.0") })`);
  console.log("=".repeat(60) + "\n");
}

main().catch((err) => {
  console.error("âŒ Deployment failed:", err);
  process.exit(1);
});
